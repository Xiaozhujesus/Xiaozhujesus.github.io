<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="generator" content="Hugo 0.65.3" />

  <title>Stay Foolish, Stay Hungry!</title>

    

  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/pure-min.css">

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-old-ie-min.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-min.css">
  <!--<![endif]-->

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://xiaozhujesus.github.io/css/side-menu-old-ie.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://xiaozhujesus.github.io/css/side-menu.css">
  <!--<![endif]-->

  <link rel="stylesheet" href="https://xiaozhujesus.github.io/css/blackburn.css">

  
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.9.0/css/all.css">

  
  <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

 
  
  <link rel="alternate" type="application/rss+xml" title="Stay Foolish, Stay Hungry!"
    href='https://xiaozhujesus.github.io/index.xml' />
  

  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/androidstudio.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  
  <script>hljs.initHighlightingOnLoad();</script>
  

  <link rel="shortcut icon" href="https://xiaozhujesus.github.io/img/favicon.ico" type="image/x-icon" />

  
  

</head>


<body>
<div id="layout">

  
<a href="#menu" id="menuLink" class="menu-link">
  
  <span></span>
</a>
<div id="menu">

  
  <a class="pure-menu-heading brand" href="https://xiaozhujesus.github.io/">Blackburn</a>


  <div class="pure-menu">
    <ul class="pure-menu-list">
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://xiaozhujesus.github.io/"><i class='fa fa-home fa-fw'></i>Home</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://xiaozhujesus.github.io/post/"><i class='fa fa-list fa-fw'></i>Posts</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://xiaozhujesus.github.io/about/"><i class='fa fa-user fa-fw'></i>About</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://xiaozhujesus.github.io/contact/"><i class='fa fa-phone fa-fw'></i>Contact</a>
      
        </li>
      
    </ul>
  </div>

  <div class="pure-menu social">
  <ul class="pure-menu-list">

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href='https://xiaozhujesus.github.io/index.xml'><i
          class="fas fa-rss"></i>RSS</a>
    </li>
    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://twitter.com/*" rel="me" target="_blank"><i class="fab fa-twitter-square fa-fw"></i>Twitter</a>
    </li>
    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://facebook.com/*" rel="me" target="_blank"><i class="fab fa-facebook-square fa-fw"></i>Facebook</a>
    </li>
    

    

    

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://instagram.com/*" rel="me" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
    </li>
    

    

    

    

    

    

    

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://linkedin.com/in/*" rel="me" target="_blank"><i class="fab fa-linkedin"></i></i>LinkedIn</a>
    </li>
    

    

    

    

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://github.com/yoshiharuyamashita" rel="me" target="_blank"><i class="fab fa-github-square fa-fw"></i>GitHub</a>
    </li>
    

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://stackoverflow.com/users/*" rel="me" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>Stack Overflow</a>
    </li>
    

    

    

    

    

    

    

    

    

    

  </ul>
</div>


  <div>
  <div class="small-print">
    <small>&copy; 2016. All rights reserved.</small>
  </div>
  <div class="small-print">
    <small>Built with&nbsp;<a href="https://gohugo.io/" target="_blank">Hugo</a></small>
    <small>Theme&nbsp;<a href="https://github.com/yoshiharuyamashita/blackburn" target="_blank">Blackburn</a></small>
  </div>
</div>

</div>


  <div id="main">


<div class="header">
  <h1>Stay Foolish, Stay Hungry!</h1>
  <h2>A Hugo Theme</h2>
</div>

<div class="content">
  
    <article>
  <header>
    <h2><a href="https://xiaozhujesus.github.io/post/zab/">Zab</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>19 Jul 2020, 20:41</time>
  </div>

  

  

  

</div>

  </header>

  <p>
  outstanding transaction:被提出但是为提交
zab 使用 FIFO channal 通信，可以同时处理多个 outstanding transaction；但是 Paxos 并不要求使用 FIFO channel 进行通信，所以消息有可能丢失或者乱序，因此不可以有多个 outstanding transaction，每次只能处理一个 transaction，吞吐量比较低；可以将多个有顺序要求的更新请求封装到一个请求中来解决，但是效率还是很低
3 个阶段 Zab 协议有 3 个阶段
 discovery synchronization broadcast  每个进程按 3 个阶段的顺序执行该协议，进程可以中途放弃本轮协议的执行，开始新一轮协议的执行，例如执行到第二阶段后放弃执行，从第一阶段开始重新执行
2 种角色 Zab 协议中有两种角色，leader 和 follower，论文中引入了 leader oracle 这样一个逻辑组件，原文如下：
Each process implements a leader oracle, and the leader oracle provides the identifier of the prospective leader l.
也就是说，每个进程实现了一个 leader oracle，是用来在选举开始时候，协商选举出 prospective leader 节点的；在第一阶段，进程咨询其 leader oracle ，应该 follow 哪个节点，即哪个节点为 prospective leader，被 leader oracle 选为 prospective leader 还无法成为真正的 leader，还需要经过第二阶段才可以
  </p>

  
  <footer>
    <a href="https://xiaozhujesus.github.io/post/zab/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="https://xiaozhujesus.github.io/post/raft/">Raft</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>14 Jul 2020, 17:07</time>
  </div>

  

  

  

</div>

  </header>

  <p>
  raft 分为两个部分，leader 选举和日志备份
每个 server 在 3 种 state 中的一个：leader, follower, or candidate follower 不主动发送 request，只是响应 leader 和 candidate 的请求
使用 RPC 通信，有两种 RPC：RequestVote RPC 和 AppendEntries RPC，前者用于 leader 选举，后者用于心跳（没有日志内容的 AppendEntries RPC）和日志备份，节点会以定时的方式不断发送 RPC，直到该 RPC 收到响应
leader 选举 leader 周期发送心跳给 follower，当 follower 在 election timeout 周期内没有收到 leader 的心跳时候，状态改为 candidate，然后开始发起新一轮选举
 增加 current term，state 转换为 candidate， 给自己投票，并发送 RequestVote RPC 给集群其他节点  节点会一直重复上面的步骤直到下面一种情况发生：
 赢得选举 其他节点赢得选举 超时还没有选举出 leader  赢得选举 在每个 term 投票中，每个节点只能投一票，当某个节点收到相同 term 超过半数节点的支持时候，就赢得选举；超过半数规则保证了每个 term 只能有一个 leader；赢得选举后，节点向其他节点发送心跳，阻止进一步选举
  </p>

  
  <footer>
    <a href="https://xiaozhujesus.github.io/post/raft/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="https://xiaozhujesus.github.io/post/cap/">CAP</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>08 Jul 2020, 20:03</time>
  </div>

  

  

  

</div>

  </header>

  <p>
  分布式系统有 3 个指标：
 Consistency Availability Partition tolerance  加州大学的计算机科学家 Eric Brewer 指出，这三个指标不可能同时满足
Consistency 一致性分为很多种：
 弱一致性（Weak）：写入一个数据 a 成功后，在数据副本上可能读出来，也可能读不出来，不能保证多长时间之后每个副本的数据一定是一致的。 最终一致性（Eventually）：写入一个数据 a 成功后，在其他副本有可能读不到 a 的最新值，但在某个时间窗口之后保证最终能读到，可以看做弱一致性的一个特例，这里面的重点是这个时间窗口。 强一致性（Strong）：数据 a 一旦写入成功，在任意副本任意时刻都能读到 a 的最新值。  最终一致性还可以继续细分，大家更喜欢把除了弱一致性和强一致性的其他一致性全部归为最终一致性。
弱一致性和最终一致性的副本同步是采用异步的方式，而强一致性一般要求同步更新副本，然后才能返回成功，否则很难满足任意副本任意时刻都能读到最新值，异步的通常意味着更好的吞吐量，但也意味着更复杂的架构，更复杂的开发、调试。同步意味着简单，但也意味着响应时间更长，吞吐量的更低。
 Backups，通常不会用在生产环境； M/S，master/slave,可以异步，也可以同步，写是瓶颈点； MM，multi-master，可以解决写的问题，复杂度在于如何解决冲突； 2PC，2 Phase Commit，强一致，性能低，不高可用； Paxos，它是完全分布的。没有单一的主协调员  从图中可以看出，如果要满足强一致性，有两种方案：
 2PC，吞吐量低，响应时间高，随着节点数增加，性能指数级下降 Paxos，实现成本较高，不过现在有 raft 了，容易实现，容易理解  CAP 定理中的一致性是指强一致性，也就是所有 client 节点访问同一份最新的数据副本
Availability 每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据
Partition tolerance 以实际效果而言，分区容错相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择，很明显，如果在发生分区时，选择了 C，意味着所有节点都需要同步更新数据后才能给 client 返回结果，而由于网络分区，系统会卡在这里导致不可用，也就是失去了 A；如果发生分区时候选择了 A，意味着需要给 client 返回请求结果，那么就会在无法更新所有节点的情况下给 client 返回响应，同时访问到分区内节点的 client 得到的就是旧的数据，导致失去了 C；如果没有发生分区，那么 C 和 A 是可以同时满足的
  </p>

  
  <footer>
    <a href="https://xiaozhujesus.github.io/post/cap/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="https://xiaozhujesus.github.io/post/java-interrupt/">Java Interrupt</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>02 Jul 2020, 09:37</time>
  </div>

  

  

  

</div>

  </header>

  <p>
  Java 中停止一个线程不能用 stop，因为 stop 会瞬间强行停止一个线程，且该线程持有的锁并不能释放。大家多习惯于用 interrupt，那么使用它又有什么需要注意的呢？
interrupt 相关的方法 public boolean isInterrupted() public void interrupt() public static boolean interrupted() boolean isInterrupted() 每个线程都一个状态位用于标识当前线程对象是否是中断状态。isInterrupted 主要用于判断当前线程对象的中断标志位是否被标记了，如果被标记了则返回 true，表示当前已经被中断，否则返回 false。我们也可以看看它的实现源码：
public boolean isInterrupted() { return isInterrupted(false); } private native boolean isInterrupted(boolean ClearInterrupted); 底层调用的 native 方法 isInterrupted，传入一个 boolean 类型的参数，用于指定调用该方法之后是否需要清除该线程的中断标识位。从这里我们也可以看出来，调用 isInterrupted()并不会清除线程的中断标识位。
void interrupt() interrupt()用于设置当前线程对象的中断标识位，其源码为：
public void interrupt() { // 检查当前线程是否有权限修改目标线程，如果没有，则会抛出异常SecurityException  if (this != Thread.currentThread()) checkAccess(); synchronized (blockerLock) { Interruptible b = blocker; if (b != null) { interrupt0(); // Just to set the interrupt flag  b.
  </p>

  
  <footer>
    <a href="https://xiaozhujesus.github.io/post/java-interrupt/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="https://xiaozhujesus.github.io/post/java-futuretask/">Java FutureTask</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>01 Jul 2020, 09:15</time>
  </div>

  

  

  

</div>

  </header>

  <p>
  package java.util.concurrent; import java.util.concurrent.locks.LockSupport; /** * A cancellable asynchronous computation. This class provides a base * implementation of {@link Future}, with methods to start and cancel a * computation, query to see if the computation is complete, and retrieve the * result of the computation. The result can only be retrieved when the * computation has completed; the {@code get} methods will block if the * computation has not yet completed.
  </p>

  
  <footer>
    <a href="https://xiaozhujesus.github.io/post/java-futuretask/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="https://xiaozhujesus.github.io/post/sequentially-consistent-paper/">Sequentially Consistent Paper</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>27 Jun 2020, 07:31</time>
  </div>

  

  

  

</div>

  </header>

  <p>
  处理器也许不会按照程序顺序执行指令，执行的正确性得以保证如果满足如下条件：
执行结果与顺序执行程序的结果一样，感觉是废话。。。满足这个条件的处理器是 sequential 的
现在考虑这样的计算机，由许多个这样的处理器组成，这些处理器访问共享内存，要想保证多处理器程序执行的正确性，需要满足下面的条件：
所有处理器指令的执行总的看是按照某种 sequential order，而在这个总的执行序列中，每个单独的处理器所执行的指令是按照程序指定的顺序，满足这个条件的多处理器是 sequentially consistent 的
注意，每个单独处理器的 sequentiality 并不能保证多处理器计算是 sequentially consistent 的，从上面的定义也可以看出，因为单独处理器的 sequentiality，表示处理器执行指令可以不按照程序指定的顺序，只要保证结果是对的，即与按照程序指定顺序执行结果是一样的；但是多处理器的 sequentially consistent 要求在总的执行序列中，每个单独处理器执行的指令，一定与程序指定的顺序一致，不可进行指令重排序；原因是这些指令有可能是用来在多个处理器直接同步数据访问的指令，如果重新排序，就无法保证数据同步了（下面的例子可以看出来）
文中描述了在多处理器，共享内存模型下，处理器和内存需要满足什么要求，才能保证程序正确性，在这种模型下，处理器之间只能通过共享内存通信，处理器操作我们只关心两种：从内存读数据的 fetch，和向内存写数据的 store，每个处理器的执行序列由这两种操作组成
文中说的并发程序使用的还是 two-process，即两个进程组成的程序，因为写论文时候还没有线程，所以是多进程程序；lamport 老哥举了个例子来演示问题；例子是一个互斥协议，两个进程每个都包含 critical section，协议的目的就是保证任何时刻最多只有一个进程可以执行 critical section 的代码
process 1 a := 1; if b = 0 then critical section; a = 0; else ... fi process 2 b := 1; if a = 0 then critical section; b = 0; else ... fi 说明下上面伪代码的符号，:= 是赋值，= 是比较，变量 a 和 b 初始为 0
  </p>

  
  <footer>
    <a href="https://xiaozhujesus.github.io/post/sequentially-consistent-paper/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="https://xiaozhujesus.github.io/post/disk/">Disk</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>24 May 2020, 08:54</time>
  </div>

  

  

  

</div>

  </header>

  <p>
  磁盘结构 扇区 512 字节，是磁盘读写单位，block 由多个扇区组成，是软件创建的逻辑组，用来提高读写效率，通常 4 或 8K 字节 注意，OS 每次磁盘读写操作，总是访问至少一个 block
磁盘如何连接到计算机系统
磁盘控制器作用：
 Control movement of disk heads Select a sector on a track Transfers data between disk surface and main memory Disk controller has an internal buffer to store read/write data to/from disk 1 disk controller can control n disks  硬盘结构
从上面看
 Platters are 2-sided and magnetic Platters rotates (about 10000 RPM) All disk heads move at the same time (in or out) Platter has circular tracks Tracks are divided into sectors Sector = the unit of write operation for a disk  However:Sector is too small to be efficient
  </p>

  
  <footer>
    <a href="https://xiaozhujesus.github.io/post/disk/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="https://xiaozhujesus.github.io/post/aqs/">AQS</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>22 May 2020, 08:31</time>
  </div>

  

  

  

</div>

  </header>

  <p>
  package java.util.concurrent.locks; import java.util.concurrent.TimeUnit; import java.util.ArrayList; import java.util.Collection; import java.util.Date; import sun.misc.Unsafe; public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable { private static final long serialVersionUID = 7373984972572414691L; protected AbstractQueuedSynchronizer() { } static final class Node { /** Marker to indicate a node is waiting in shared mode */ static final Node SHARED = new Node(); /** Marker to indicate a node is waiting in exclusive mode */ static final Node EXCLUSIVE = null; /** waitStatus value to indicate thread has cancelled */ static final int CANCELLED = 1; /** waitStatus value to indicate successor&#39;s thread needs unparking */ static final int SIGNAL = -1; /** waitStatus value to indicate thread is waiting on condition */ static final int CONDITION = -2; /** * waitStatus value to indicate the next acquireShared should * unconditionally propagate */ static final int PROPAGATE = -3; volatile int waitStatus; volatile Node prev; volatile Node next; volatile Thread thread; Node nextWaiter; final boolean isShared() { return nextWaiter == SHARED; } final Node predecessor() throws NullPointerException { Node p = prev; if (p == null) throw new NullPointerException(); else return p; } Node() { // Used to establish initial head or SHARED marker  } Node(Thread thread, Node mode) { // Used by addWaiter  this.
  </p>

  
  <footer>
    <a href="https://xiaozhujesus.github.io/post/aqs/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="https://xiaozhujesus.github.io/post/jni/">JNI</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>22 May 2020, 08:26</time>
  </div>

  

  

  

</div>

  </header>

  <p>
  JNI Java native interface，jvm 用来调用具体平台上的 native 代码（通常是 C 和 C++）的方法
1.原理 native executable 程序通常可以使用 static 或 shared 的 lib
 static lib 通常在链接阶段会被链接到最终的可执行程序中 shared lib，最终的可执行文件只包含共享库的引用而不是代码  JNI 使用的就是 shared lib 技术实现的，我理解应该是 jvm（C++写的）调用 shared lib，这些文件以 .so/.dll/.dylib结尾，既不在 class 文件里，也不在 jvm 里；jvm 构造一个指针表，表中的指针指向 native method 的内存地址，这样就可以调用 native method 了
1.1 需要的组件  Java code，class 中至少包含一个 native method native code，通常使用 C/C++编写 JNI header file，是个 C/C++头文件，包含所有 JNI 元素的定义（jni.h） C/C++ Compiler，编译出 native shared library  1.2 代码中的 JNI 元素 Java 部分  任何声明为 native 的 method 都必须在 native shared library 中实现 System.
  </p>

  
  <footer>
    <a href="https://xiaozhujesus.github.io/post/jni/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="https://xiaozhujesus.github.io/post/linux-file/">Linux File</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>21 May 2020, 08:00</time>
  </div>

  

  

  

</div>

  </header>

  <p>
  大多数文件 IO 用到 5 个函数，这些函数是系统调用而不是库函数，会陷入内核
 open read write lseek close  open 必选项如下：
 O_RDONLY O_WRONLY O_RDWR O_EXEC O_SEARCH  可选项如下：
 O_APPEND O_CLOEXEC O_CREAT O_DIRECTORY O_EXCL O_NOFOLLOW O_NOBLOCK O_TRUNC O_SYNC O_DSYNC O_RSYNC  这里主要说下可选项的后三个
O_SYNC 每次 write 等待物理 IO 操作完成，包括由该 write 引起的文件属性更新所需要的 IO
O_DSYNC 每次 write 要等待物理 IO 操作完成，但是如果该写操作并不影响读取刚写入的数据，则不需要等待文件属性被更新
O_DSYNC 与 O_SYNC 有微妙的区别，仅当文件属性需要更新以反映文件数据变化时候，例如更新文件大小以反应文件中有更多数据，就可以看出二者的区别；设置 O_SYNC 后文件数据和属性总是同步更新，而 O_DSYNC 选项，当使用 write 重写文件现有部分内容时候，文件时间属性不会同步更新，但是会更新，只是 write 返回时候只是保证数据被更新了，而文件元数据则会在稍后某个时间更新
O_RSYNC 使得每个以文件描述符为参数的 read 操作等待，直至所有对文件同一部分挂起的写操作都完成
Solaris 支持所有这 3 个选项，而 Linux 处理 O_RSYNC 与处理 O_SYNC 相同
  </p>

  
  <footer>
    <a href="https://xiaozhujesus.github.io/post/linux-file/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  

  


<nav class="pagination" role="pagination">
  
  <i class="fa fa-chevron-left"></i>
  
  <span>&nbsp;1 / 4&nbsp;</span>
  
  <a href="https://xiaozhujesus.github.io/page/2/"><i class="fa fa-chevron-right"></i></a>
  
</nav>



</div>

</div>
</div>
<script src="https://xiaozhujesus.github.io/js/ui.js"></script>
<script src="https://xiaozhujesus.github.io/js/menus.js"></script>


<script>
  
  if (window.location.hostname != "localhost") {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'Your Google Analytics tracking ID', 'auto');
    ga('send', 'pageview');
  }
</script>







</body>
</html>

