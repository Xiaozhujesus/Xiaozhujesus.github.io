<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="generator" content="Hugo 0.65.3" />

  <title>Stay Foolish, Stay Hungry!</title>

    

  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/pure-min.css">

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-old-ie-min.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-min.css">
  <!--<![endif]-->

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://xiaozhujesus.github.io/css/side-menu-old-ie.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://xiaozhujesus.github.io/css/side-menu.css">
  <!--<![endif]-->

  <link rel="stylesheet" href="https://xiaozhujesus.github.io/css/blackburn.css">

  
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.9.0/css/all.css">

  
  <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

 
  
  <link rel="alternate" type="application/rss+xml" title="Stay Foolish, Stay Hungry!"
    href='https://xiaozhujesus.github.io/index.xml' />
  

  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/androidstudio.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  
  <script>hljs.initHighlightingOnLoad();</script>
  

  <link rel="shortcut icon" href="https://xiaozhujesus.github.io/img/favicon.ico" type="image/x-icon" />

  
  

</head>


<body>
<div id="layout">

  
<a href="#menu" id="menuLink" class="menu-link">
  
  <span></span>
</a>
<div id="menu">

  
  <a class="pure-menu-heading brand" href="https://xiaozhujesus.github.io/">Blackburn</a>


  <div class="pure-menu">
    <ul class="pure-menu-list">
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://xiaozhujesus.github.io/"><i class='fa fa-home fa-fw'></i>Home</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://xiaozhujesus.github.io/post/"><i class='fa fa-list fa-fw'></i>Posts</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://xiaozhujesus.github.io/about/"><i class='fa fa-user fa-fw'></i>About</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://xiaozhujesus.github.io/contact/"><i class='fa fa-phone fa-fw'></i>Contact</a>
      
        </li>
      
    </ul>
  </div>

  <div class="pure-menu social">
  <ul class="pure-menu-list">

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href='https://xiaozhujesus.github.io/index.xml'><i
          class="fas fa-rss"></i>RSS</a>
    </li>
    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://twitter.com/*" rel="me" target="_blank"><i class="fab fa-twitter-square fa-fw"></i>Twitter</a>
    </li>
    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://facebook.com/*" rel="me" target="_blank"><i class="fab fa-facebook-square fa-fw"></i>Facebook</a>
    </li>
    

    

    

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://instagram.com/*" rel="me" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
    </li>
    

    

    

    

    

    

    

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://linkedin.com/in/*" rel="me" target="_blank"><i class="fab fa-linkedin"></i></i>LinkedIn</a>
    </li>
    

    

    

    

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://github.com/yoshiharuyamashita" rel="me" target="_blank"><i class="fab fa-github-square fa-fw"></i>GitHub</a>
    </li>
    

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://stackoverflow.com/users/*" rel="me" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>Stack Overflow</a>
    </li>
    

    

    

    

    

    

    

    

    

    

  </ul>
</div>


  <div>
  <div class="small-print">
    <small>&copy; 2016. All rights reserved.</small>
  </div>
  <div class="small-print">
    <small>Built with&nbsp;<a href="https://gohugo.io/" target="_blank">Hugo</a></small>
    <small>Theme&nbsp;<a href="https://github.com/yoshiharuyamashita/blackburn" target="_blank">Blackburn</a></small>
  </div>
</div>

</div>


  <div id="main">


<div class="header">
  <h1>Stay Foolish, Stay Hungry!</h1>
  <h2>A Hugo Theme</h2>
</div>

<div class="content">
  
    <article>
  <header>
    <h2><a href="https://xiaozhujesus.github.io/post/virtualization/">Virtualization</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>29 Mar 2020, 10:34</time>
  </div>

  

  

  

</div>

  </header>

  <p>
  分以下 4 个方面介绍虚拟化内容
 虚拟化基础 内存虚拟化 CPU 虚拟化 设备虚拟化  
  </p>

  
</article>

  
    <article>
  <header>
    <h2><a href="https://xiaozhujesus.github.io/post/lock/">Lock</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>28 Mar 2020, 11:34</time>
  </div>

  

  

  

</div>

  </header>

  <p>
  P1 P2     modify struct(A); wait for mod;    use struct(A);    假设只有 read/write 原子操作指令，能实现上面的两个进程的需求么？可以的 使用一个共享变量解决，flag = 0;//int
   P1 P2     mod(A) while (flag == 0 );   flag = 1;//signal P2 use(A)    flag = 0;//re-init    注意上面的所有操作都是 read/write 内存访问，都是原子操作；flag 变量是同步变量，struct A 是普通数据
原子操作 看一个简单互斥锁的实现
lock(L): if(L == 0) &lt;--- L = 1; | else | while(L==1); | //wait | go back; ------ unlock(L): L = 0; 只用原子 read/write 操作可以实现上面的互斥锁么？注意，上面的 if(L == 0) L = 1;实际上需要 3 条指令来完成，首先从内存读变量 L，然后检查是否为 0，如果是，向内存位置 L 存入新的值 1；这 3 条指令必须以原子不可分的方式执行才能保证算法的正确性；虽然单个的 read/write 操作是原子的，但是一组 read/write 操作就不是原子的了；所以为了正确实现互斥锁，我们需要新的原子指令，语意为从内存读数据，然后修改，最后写回内存（read,modify,write，简称 rmw）
  </p>

  
  <footer>
    <a href="https://xiaozhujesus.github.io/post/lock/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="https://xiaozhujesus.github.io/post/shared-memory-machine-model/">Shared Memory Machine Model</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>26 Mar 2020, 11:51</time>
  </div>

  

  

  

</div>

  </header>

  <p>
  介绍 3 种不同结构的共享内存机器模型，共享内存意思是每个 CPU 都可以访问所有内存空间，但缓存是每个 CPU 独有的，无法相互访问
Dance Hall Architecture SMP Architecture Symmetric Multiprocessor，对称是因为每个 cpu 的访存时间相同，
Distributor Shared Memory Architecture 每个 CPU 有一个关联的内存，每个 CPU 都可以通过系统总线访问到其他 CPU 关联的内存，但是访问自己的内存比较快
Shared Memory And Caches 这里以 SMP 架构为例进行讲解。
单 CPU 架构下，CPU 访问内存时，首先访问 cache，如果 cache 命中，则直接访问，否则访问内存，同时将结果缓存在 cache 中；多 CPU 架构下 cache 的作用与单 CPU 一样，但是有个问题就是 cache 是 CPU 私有的，memory 是 CPU 共享的，假设内存有个热点变量 var 值为 y，缓存在所有 CPU 的 cache 中，当 cpu1 对私有 cache 中的 var 修改时，假设修改后的值为 x，那么所有 CPU 的 cache 中的 var 现在都应该是 x，这点应该由谁来保证呢？
  </p>

  
  <footer>
    <a href="https://xiaozhujesus.github.io/post/shared-memory-machine-model/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="https://xiaozhujesus.github.io/post/synchronization/">OS Synchronization</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>24 Mar 2020, 07:59</time>
  </div>

  

  

  

</div>

  </header>

  <p>
  共享内存模型下的同步元语  互斥锁（mutual exclusive lock）：同时最多只能有一个线程使用 条件变量（condition variable）：阻塞等待被条件满足，得到通知 信号量（semaphores）： 共享锁（shared lock）：多个线程可以同时使用，通常是读锁 屏障（barrier）：所有线程都到达，才能继续执行  后面我们每个分别讨论
  </p>

  
</article>

  
    <article>
  <header>
    <h2><a href="https://xiaozhujesus.github.io/post/sequential-consistency/">Sequential Consistency</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>20 Mar 2020, 09:24</time>
  </div>

  

  

  

</div>

  </header>

  <p>
  顺序一致性不具有完全可用性或强可以用性（totally or sticky available）。 如果发生网络分区，则某些或所有节点将无法前进。
顺序一致的系统中的一个进程可能比其他进程领先或落后。 例如，他可以读取任意陈旧状态。 但是，一旦进程 A 观察到了来自进程 B 的某些操作，就永远无法观察到 B 之前的状态。再加上 total order 属性，使得顺序一致性对于程序员来说成为了很强的模型。
当您需要实时约束时，请使用 linearizability；如果您需要 total availability，而又不需要 total order，请尝试因果一致性（causal consistency）。
莱斯利·兰珀特（Leslie Lamport）在 1979 年的论文《如何制造能正确执行多进程程序的多处理器计算机》中定义了顺序一致性。 他使用“顺序一致”：
the result of any execution is the same as if the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order specified by its program
上述定义中隐含了 SMP 系统可能不满足顺序一致性
  </p>

  
  <footer>
    <a href="https://xiaozhujesus.github.io/post/sequential-consistency/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="https://xiaozhujesus.github.io/post/ssl/">SSL</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>12 Mar 2020, 18:20</time>
  </div>

  

  

  

</div>

  </header>

  <p>
  PKI，CA 和数字证书 PKI 就是 Public Key Infrastructure 的缩写，翻译过来就是公开密钥基础设施。它是利用公开密钥技术所构建的，解决网络安全问题的，普遍适用的一种基础设施;是一种遵循既定标准的密钥管理平台,它能够为所有网络应用提供加密和数字签名等密码服务及所必需的密钥和证书管理体系。
PKI 既不是一个协议，也不是一个软件，它是一个标准，在这个标准之下发展出的为了实现安全基础服务目的的技术统称为 PKI。可以说 CA(认证中心)是 PKI 的核心，而数字证书是 PKI 的最基本元素
CA 为保证用户之间在网上传递信息的安全性、真实性、可靠性、完整性和不可抵赖性
CA 机构，又称为证书认证中心 (Certificate Authority) 中心，是一个负责发放和管理数字证书的第三方权威机构，它负责管理 PKI 结构下的所有用户(包括各种应用程序)的证书，把用户的公钥和用户的其他信息捆绑在一起，在网上验证用户的身份。CA 机构的数字签名使得攻击者不能伪造和篡改证书。
认证中心主要有以下 5 个功能：
 证书的颁发：接收、验证用户(包括下级认证中心和最终用户)的数字证书的申请。可以受理或拒绝 证书的更新：认证中心可以定期更新所有用户的证书，或者根据用户的请求来更新用户的证书 证书的查询：查询当前用户证书申请处理过程；查询用户证书的颁发信息，这类查询由目录服务器 ldap 来完成 证书的作废：由于用户私钥泄密等原因，需要向认证中心提出证书作废的请求；证书已经过了有效期，认证中心自动将该证书作废。认证中心通过维护证书作废列表 (Certificate Revocation List,CRL) 来完成上述功能。 证书的归档：证书具有一定的有效期，证书过了有效期之后就将作废，但是我们不能将作废的证书简单地丢弃，因为有时我们可能需要验证以前的某个交易过程中产生的数字签名，这时我们就需要查询作废的证书。  X.509 标准 &ldquo;SSL 证书&quot;这个词是一个相对较大的概念，整个 PKI 体系中有很多 SSL 证书格式标准。PKI 的标准规定了 PKI 的设计、实施和运营，规定了 PKI 各种角色的&quot;游戏规则&rdquo;，提供数据语法和语义的共同约定。x.509 是 PKI 中最重要的标准，它定义了公钥证书的基本结构，可以说 PKI 是在 X.509 标准基础上发展起来的
SSL 公钥证书格式 1. 证书版本号(Version) 版本号指明X.509证书的格式版本，现在的值可以为: 1) 0: v1 2) 1: v2 3) 2: v3 也为将来的版本进行了预定义 2.
  </p>

  
  <footer>
    <a href="https://xiaozhujesus.github.io/post/ssl/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="https://xiaozhujesus.github.io/post/ldap%E5%9F%BA%E7%A1%80/">Ldap基础</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>12 Mar 2020, 11:34</time>
  </div>

  

  

  

</div>

  </header>

  <p>
  LDAP是一款轻量级目录访问协议（Lightweight Directory Access Protocol,LDAP），基于X.500标准，且支持TCP/IP协议；默认以Berkeley DB作为后端数据库，对于一次写入、多次查询和搜索的操作能够提供较好的支持；基于C/S架构，非常适合用于实现账号的集中管理和维护。本文将对LDAP的基本概念、常用命令以及基本操作进行简要介绍
基本概念 LDAP数据组织方式 LDAP默认使用Berkeley DB作为后端数据库，主要以散列的数据类型（如键值对）来组织数据。对于LDAP中的数据记录，Berkeley从中提取指定属性组来作为该记录的标识名（可定位到该记录的目录），并将这些属性按树状结构来组织，与关系型数据库相比，可显著提高查询性能。典型的LDAP的目录组织结构如下图所示：
entry 条目，也称记录项，是LDAP中存储和组织数据的基本单元，对LDAP相关的增、删、改、查等操作都是以条目为基本单元的。例如，每一个用户的相关信息在LDAP中都是以条目的形式存储和使用的，包括该用户的标识名以及其他属性。每一个条目都有一个标识名（distinguished name,dn），用于在LDAP中唯一地标识该条目；LDAP中条目的标识名即是该条目的目录，例如，对于用户userA，其标识名为&quot;dn:uid=userA,ou=People,dc=zenandidi,dc=com&rdquo;。
attribute 属性，用于描述条目包含的相关信息。LDAP中的属性可分为必要属性(MUST)和可选属性(MAY)两种，新建条目时，必须为必要属性赋值；除定义中指明&quot;SINGLE-VALUE&quot;外，默认情况下，属性可具有多个值。人员组织机构中有如下常见属性：
   属性 描述 举例     uid (user id) 指用户的登录名称 uid=userA   cn (common name) 指用户的全名 cn=userA   sn (sur name) 指用户的姓氏 sn=wang   mail 指用户的邮箱地址 mail: userA@gmail.com   telephoneNumber 指用户的联系方式 telephoneNumber: 123456   ou (organizationalUnit) 指一个组织单位的名称 ou=people   dc (domain component) 指一个域名 dc=baidu,dc=com   c (country name) 指一个国家的名称 c: CN   rdn (relative dn) 指用户的相对标识名 uid=userA   objectClass 内置属性，该对象中包含的属性可供条目使用 objectClass: inetOrgPerson    objectClass LDAP中，一个条目(Entry)必须包含一个对象类(objectClass)属性，且需要赋予至少一个值。每一个值将用作一条LDAP条目进行数据存储的模板；模板中包含了一个条目必须被赋值的属性和可选的属性。通过组合不同的对象类，可方便的定义条目。
  </p>

  
  <footer>
    <a href="https://xiaozhujesus.github.io/post/ldap%E5%9F%BA%E7%A1%80/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="https://xiaozhujesus.github.io/post/ldap%E5%AE%89%E8%A3%85/">Ldap安装</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>12 Mar 2020, 11:02</time>
  </div>

  

  

  

</div>

  </header>

  <p>
  安装前环境准备 在安装OPENLDAP之前需要关闭防火墙
[wz]# systemctl stop firewalld.service [wz]# systemctl disable firewalld.service OPENLDAP-servers安装及配置 安装 [wz]# yum install -y openldap-servers 配置  配置管理员密码  [wz]# slappasswd -s passwd {SSHA}2e1yDU9g9VSc8UArkfpi5KsjT9mSZxCN 修改配置文件  olcDbDirectory：指定ldap数据库的路径；
olcSuffix：指定管理员管理的目录树根域；
olcRootDN：指定管理员dn；
olcRootPW：该字段需要自行添加，用于指定管理员密码，将上一步生成的加密字符串添加在这一行；
[wz]# vim /etc/openldap/slapd.d/cn\=config/olcDatabase\=\{2\}hdb.ldif # AUTO-GENERATED FILE - DO NOT EDIT!! Use ldapmodify. # CRC32 1763c834 dn: olcDatabase={2}hdb objectClass: olcDatabaseConfig objectClass: olcHdbConfig olcDatabase: {2}hdb olcDbDirectory: /var/lib/ldap olcSuffix: dc=com olcRootDN: cn=Manager,dc=com olcRootPW: {SSHA}2e1yDU9g9VSc8UArkfpi5KsjT9mSZxCN olcDbIndex: objectClass eq,pres olcDbIndex: ou,cn,mail,surname,givenname eq,pres,sub structuralObjectClass: olcHdbConfig entryUUID: b5baf318-0bee-1039-9713-29cc6215f8f1 creatorsName: cn=config createTimestamp: 20190516062222Z entryCSN: 20190516062222.
  </p>

  
  <footer>
    <a href="https://xiaozhujesus.github.io/post/ldap%E5%AE%89%E8%A3%85/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="https://xiaozhujesus.github.io/post/logical-vector-clock/">Logical-Clock和Vector-Clock</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>01 Mar 2020, 19:12</time>
  </div>

  

  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="https://xiaozhujesus.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F">分布式</a>
    
  </div>
  
  

</div>

  </header>

  <p>
  早在在 1978 年，Leslie Lamport 就提出逻辑时钟的概念。在分布式环境中，通过一系列规则来定义逻辑时钟的变化。从而能通过逻辑时钟来对分布式系统中的事件的先后顺序进行判断。
逻辑时钟本质上定义了一种 happen before 关系，记作-&gt;，a-&gt;b 意味着所有的进程都“认可”事件 a 发生在事件 b 之前。happen before 关系满足传递性：即(a-&gt;b &amp;&amp; b-&gt;c)可以推导出(a-&gt;c)。
Logical Clock lamport 逻辑时钟算法：
 每个事件对应一个 Lamport 时间戳，初始值为 0 如果事件在节点内发生，时间戳加 1 如果事件属于发送事件，时间戳加 1 并在消息中带上该时间戳 如果事件属于接收事件，时间戳 = Max(本地时间戳，消息中的时间戳) + 1  三个机器上各自跑着一个进程，分别为 P1,P2,P3，由于不同的机器上的物理时钟、CPU 负载、或者 CPU 频率不一样，所以不同的机器上的时钟速率可能是不同的，例当 P1 所在的机器 tick 了 6 次，P2 所在的机器 tick 了 8 次，就是异步网络中指的漂移时钟不同。
图中，P1 给 P2 发送了消息 m1，m1 上附带了发送 m1 时的时钟 6，随后 P2 收到了 m1，根据 P2 接收到 m1 时的时钟，认为传输消息花了 16-6=10 个 tick，随后，P3 给 P2 发送消息 m3，m3 附带的发送时钟是 60。由于 P2 的时钟走的比 P3 的慢，所以接收到 m3 时，本机的时钟 56 比发送时钟 60 小，这是不合理的，需要调整时钟，如图中，将 P2 的 56 调整为 61，即 m3 的发送时钟加 1。
  </p>

  
  <footer>
    <a href="https://xiaozhujesus.github.io/post/logical-vector-clock/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  

  


<nav class="pagination" role="pagination">
  
  <a href="https://xiaozhujesus.github.io/"><i class="fa fa-chevron-left"></i></a>
  
  <span>&nbsp;2 / 2&nbsp;</span>
  
  <i class="fa fa-chevron-right"></i>
  
</nav>



</div>

</div>
</div>
<script src="https://xiaozhujesus.github.io/js/ui.js"></script>
<script src="https://xiaozhujesus.github.io/js/menus.js"></script>


<script>
  
  if (window.location.hostname != "localhost") {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'Your Google Analytics tracking ID', 'auto');
    ga('send', 'pageview');
  }
</script>







</body>
</html>

