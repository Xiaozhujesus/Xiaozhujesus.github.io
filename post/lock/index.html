<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="generator" content="Hugo 0.65.3" />

  <title>Lock &middot; Stay Foolish, Stay Hungry!</title>

    

  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/pure-min.css">

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-old-ie-min.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-min.css">
  <!--<![endif]-->

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://xiaozhujesus.github.io/css/side-menu-old-ie.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://xiaozhujesus.github.io/css/side-menu.css">
  <!--<![endif]-->

  <link rel="stylesheet" href="https://xiaozhujesus.github.io/css/blackburn.css">

  
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.9.0/css/all.css">

  
  <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

 
  

  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/androidstudio.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  
  <script>hljs.initHighlightingOnLoad();</script>
  

  <link rel="shortcut icon" href="https://xiaozhujesus.github.io/img/favicon.ico" type="image/x-icon" />

  
  

</head>


<body>
<div id="layout">

  
<a href="#menu" id="menuLink" class="menu-link">
  
  <span></span>
</a>
<div id="menu">

  
  <a class="pure-menu-heading brand" href="https://xiaozhujesus.github.io/">Blackburn</a>


  <div class="pure-menu">
    <ul class="pure-menu-list">
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://xiaozhujesus.github.io/"><i class='fa fa-home fa-fw'></i>Home</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://xiaozhujesus.github.io/post/"><i class='fa fa-list fa-fw'></i>Posts</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://xiaozhujesus.github.io/about/"><i class='fa fa-user fa-fw'></i>About</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://xiaozhujesus.github.io/contact/"><i class='fa fa-phone fa-fw'></i>Contact</a>
      
        </li>
      
    </ul>
  </div>

  <div class="pure-menu social">
  <ul class="pure-menu-list">

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://twitter.com/*" rel="me" target="_blank"><i class="fab fa-twitter-square fa-fw"></i>Twitter</a>
    </li>
    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://facebook.com/*" rel="me" target="_blank"><i class="fab fa-facebook-square fa-fw"></i>Facebook</a>
    </li>
    

    

    

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://instagram.com/*" rel="me" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
    </li>
    

    

    

    

    

    

    

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://linkedin.com/in/*" rel="me" target="_blank"><i class="fab fa-linkedin"></i></i>LinkedIn</a>
    </li>
    

    

    

    

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://github.com/yoshiharuyamashita" rel="me" target="_blank"><i class="fab fa-github-square fa-fw"></i>GitHub</a>
    </li>
    

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://stackoverflow.com/users/*" rel="me" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>Stack Overflow</a>
    </li>
    

    

    

    

    

    

    

    

    

    

  </ul>
</div>


  <div>
  <div class="small-print">
    <small>&copy; 2016. All rights reserved.</small>
  </div>
  <div class="small-print">
    <small>Built with&nbsp;<a href="https://gohugo.io/" target="_blank">Hugo</a></small>
    <small>Theme&nbsp;<a href="https://github.com/yoshiharuyamashita/blackburn" target="_blank">Blackburn</a></small>
  </div>
</div>

</div>


  <div id="main">


<div class="header">
  <h1>Lock</h1>
  <h2></h2>
</div>
<div class="content">

  <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>28 Mar 2020, 11:34</time>
  </div>

  

  

  

</div>

  <table>
<thead>
<tr>
<th align="center">P1</th>
<th align="center">P2</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">modify struct(A);</td>
<td align="center">wait for mod;</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">use struct(A);</td>
</tr>
</tbody>
</table>
<p>假设只有 read/write 原子操作指令，能实现上面的两个进程的需求么？可以的
使用一个共享变量解决，flag = 0;//int</p>
<table>
<thead>
<tr>
<th align="center">P1</th>
<th align="center">P2</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">mod(A)</td>
<td align="center">while (flag == 0 );</td>
</tr>
<tr>
<td align="center">flag = 1;//signal P2</td>
<td align="center">use(A)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">flag = 0;//re-init</td>
</tr>
</tbody>
</table>
<p>注意上面的所有操作都是 read/write 内存访问，都是原子操作；flag 变量是同步变量，struct A 是普通数据</p>
<h2 id="原子操作">原子操作</h2>
<p>看一个简单互斥锁的实现</p>
<pre><code>lock(L):
    if(L == 0)      &lt;---
        L = 1;          |
    else                |
        while(L==1);    |
        //wait          |
        go back;  ------

unlock(L):
    L = 0;
</code></pre><p>只用原子 read/write 操作可以实现上面的互斥锁么？注意，上面的 if(L == 0) L = 1;实际上需要 3 条指令来完成，首先从内存读变量 L，然后检查是否为 0，如果是，向内存位置 L 存入新的值 1；这 3 条指令必须以原子不可分的方式执行才能保证算法的正确性；虽然单个的 read/write 操作是原子的，但是一组 read/write 操作就不是原子的了；所以为了正确实现互斥锁，我们需要新的原子指令，语意为从内存读数据，然后修改，最后写回内存（read,modify,write，简称 rmw）</p>
<p>现在已经提出了许多种 rmw 指令，并且已经被处理器实现，下面介绍几个：</p>
<ul>
<li>
<p>test-and-set(<!-- raw HTML omitted -->)指令</p>
<p>该指令返回内存位置 mem-loc 的值，设置该位置的值为 1</p>
</li>
<li>
<p>fetch-and-inc(<!-- raw HTML omitted -->)指令</p>
<p>该指令返回内存位置 mem-loc 的值，并增加该内存位置的值</p>
</li>
</ul>
<p>还有许多其他提供复杂语义的原子操作这里就不一一介绍了</p>
<h2 id="同步的可扩展问题">同步的可扩展问题</h2>
<p>如果你在多处理器共享内存这种模型上实现同步算法，需要考虑一些问题</p>
<ul>
<li>延迟（latency）</li>
</ul>
<p>假设现在锁是空闲的，需要花费多久的时间获取锁；主要是访问内存并判断的时间</p>
<ul>
<li>等待时间（waiting time）</li>
</ul>
<p>如果想获取锁，需要等待多长时间才能获取到（锁有可能不是空闲的）</p>
<ul>
<li>竞争（contention）</li>
</ul>
<p>如果锁被释放了，因为是缓存一致性模型，每个 CPU 的缓存都会看到锁被释放了，所有在该锁上等待获取锁的线程都会通过系统总线去内存竞争锁，总线流量会加大</p>
<h2 id="最简单的自旋锁spinlocktest-and-set-实现">最简单的自旋锁（spinlock,test-and-set 实现）</h2>
<p>L 是内存变量，只可能有两个值，1(locked) 和 0(unlock)</p>
<pre><code>lock(L):
    //返回L的旧值，并且设置L的值为1；如果L的值原来为1，再次设置为1没有影响，返回原来的1，表示已经被其他线程获取，测试条件成立，不断自旋，不执行同步代码块；如果原来为0，那么设置为1表示该线程获取锁，返回原来的0，表示没有被其他线程获取，测试条件不成了，跳出循环，往下执行同步代码块
    while(test-and-set(L) == 1);

unlock(L):
    L = 0
</code></pre><p>伪代码 C 实现：</p>
<pre><code> volatile int lock = 0;

 void Critical() {
     while (TestAndSet(&amp;lock) == 1);
     critical section // only one process can be in this section at a time
     lock = 0 // release lock when finished with the critical section
 }
</code></pre><h2 id="使用缓存的自旋锁caching-spinlock">使用缓存的自旋锁(caching spinlock)</h2>
<p>这里以 SMP 系统结构为例，（即每个 CPU 有私有缓存，通过系统总线连接到共享内存），硬件提供缓存一致性功能</p>
<p>上面的自旋锁实现，每个 CPU 都会不停的执行 TAS 指令，该指令需要通过总线访存，这加大了总线流量；如果每个 CPU 访问 cache 来判断 L 的值那么，在 spin 自旋时候就可以大大减少总线流量，而当持有锁的线程释放锁时，由于硬件提供缓存一致性，每个 CPU 都会注意到锁被释放了，此时再去通过总线去内存竞争锁；由于等待获取锁自旋时候是测试 cache 变量，对总线没有压力，所以多少个 CPU 都可以</p>
<pre><code>lock(L):
    //这一步是读取变量L，如果L在cache中，直接读；否则去内存读，让后缓存在cache中
    while(L == 1);  &lt;--
    //观察到锁被释放了，开始使用TAS指令竞争锁
    if(TAS(L) == 1)    |
        go back;  -----

unlock(L):
    L = 0;
</code></pre><h2 id="延迟自旋锁spinlock-with-delay">延迟自旋锁（spinlock with delay)</h2>
<p>为了限制竞争锁时总线上的流量，需要做一些操作，想法很简单，每个 CPU 观察到锁被释放去竞争锁之前，等一小段时间，然后再去竞争；下面讨论两种不同的 delay 方法</p>
<h3 id="delay-with-lock-release">delay with lock release</h3>
<pre><code>lock(L):
    while((L == 1) or (TAS(L) == 1))
        //使用本地cache自旋
        while(L == 1);
        //等一会，每个CPU Pi等待的时间不同
        delay(d[Pi])

unlock(L):
    L = 0;
</code></pre><h3 id="delay-with-exp-backoff">delay with exp backoff</h3>
<pre><code>lock(L):
    while(TAS(L) == 1)
        delay(d);
        d = d * 2;

unlock(L):
    L = 0;
</code></pre><p>d 初始是个很小的值，每次循环变成原来的 2 倍；当锁竞争不是很激烈时候，可以在 d 很小的时候获取到锁；如果竞争很激烈，我们 backoff 的时间就会加大，这有助于避免更加激烈的竞争；注意这个算法没有使用 cache，在获取不到锁时候，直接 backoff，下次也是直接访存竞争锁，这样的话，该算法同样适合非缓存一致性多处理器结构的计算机；</p>
<p>不论上面两种算法的哪一个，通常有 delay 机制的自旋性能总是优于没有额外操作的纯自旋</p>
<h2 id="ticket-lock">Ticket Lock</h2>
<p>上面的锁没有考虑公平性的问题，当多个线程竞争锁时，是否应该让先发出获取锁请求的线程获取锁呢？自旋锁没办法区分谁先发出获取锁请求，这里想法很简单，就像去办事大厅叫号排队办事一样</p>
<p>锁数据结构有两个域，下一个可以获取锁的 index 和当前获取锁的 index</p>
<pre><code>struct lock {
    int nextTicket;
    int nowServing;
}
</code></pre><p>获取锁的算法如下：</p>
<pre><code>acquire-lock(L):
    int myTicket = fetch-and-inc(L.nextTicket);
    loop
        delay(myTicket - L.nowServing);
        if(L.nowServing == myTicket)
            return;

release-lock(L):
    L.nowServing++;
</code></pre><p>在提供公平属性的锁实现中，当前获取锁的线程释放锁时候，不需要每个竞争锁的线程都参与竞争，当前线程只需要通知下一个可以获取锁的线程即可，这样避免了锁竞争；下面介绍两种基于队列的锁</p>
<h2 id="array-based-queueing-lock">Array-based queueing Lock</h2>
<p>每个锁有一个关联的标志位数组，flag[N]，这是一个循环队列，在一个有 N 个 CPU 的计算机中，至多有 N 个请求同时等待获取该锁，数组中每个元素的值为 1 代表持有锁，为 0 代表等待获取锁；同时还有一个 last 变量表示下一个获取锁的请求应该在数组的哪个 slot 里；注意，N 个 CPU 与 N 个 slot 并不是一一对应关系，即不是第一个 CPU 对应第一个 slot，第二个 CPU 对应第二个 slot&hellip;</p>
<ul>
<li>has-lock(1)</li>
<li>must-wait(0)</li>
</ul>
<p>struct Lock {
int last;
int flag[N];
}</p>
<p>每次有线程初次请求获取锁时，操作系统都会新建一个这样的 struct，last 初始值为 N，flag 数组除了第一元素为 1，其余元素为 0</p>
<pre><code>lock(L):
    //如果系统没有实现fetch-and-inc指令，可以用test-and-inc指令实现
    myplace = fetch-and-inc(L.last);
    while(L.flag[myplace mod N] == 0);

unlock(L):
    L.flag[current mod N] = 0;
    L.flag[(current+1) mod N] = 1;
</code></pre><p>上面的算法即使没有 N 个线程同时请求锁，也要分配 N 个 slot 的数组，对于操作系统来说有些浪费资源，因为上面的锁定义是静态数据结构</p>
<h2 id="link-based-queueing-lock">Link-based queueing Lock</h2>

  
  
<style>
  ul.share-buttons {
    list-style: none;
    padding: 0;
  }

  ul.share-buttons li {
    display: inline;
  }

  ul.share-buttons .sr-only {
    position: absolute;
    clip: rect(1px 1px 1px 1px);
    clip: rect(1px, 1px, 1px, 1px);
    padding: 0;
    border: 0;
    height: 1px;
    width: 1px;
    overflow: hidden;
  }
</style>


  
<div class="prev-next-post pure-g">
  <div class="pure-u-1-24" style="text-align: left;">
    
    <a href="https://xiaozhujesus.github.io/post/shared-memory-machine-model/"><i class="fa fa-chevron-left"></i></a>
    
  </div>
  <div class="pure-u-10-24">
    
    <nav class="prev">
      <a href="https://xiaozhujesus.github.io/post/shared-memory-machine-model/">Shared Memory Machine Model</a>
    </nav>
    
  </div>
  <div class="pure-u-2-24">
    &nbsp;
  </div>
  <div class="pure-u-10-24">
    
    <nav class="next">
      <a href="https://xiaozhujesus.github.io/post/virtualization/">Virtualization</a>
    </nav>
    
  </div>
  <div class="pure-u-1-24" style="text-align: right;">
    
    <a href="https://xiaozhujesus.github.io/post/virtualization/"><i class="fa fa-chevron-right"></i></a>
    
  </div>
</div>



  
<div id="disqus_thread"></div>
<script type="text/javascript">

(function() {
    
    
    if (window.location.hostname == "localhost")
        return;

    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    var disqus_shortname = 'Your Disqus shortname';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


</div>

</div>
</div>
<script src="https://xiaozhujesus.github.io/js/ui.js"></script>
<script src="https://xiaozhujesus.github.io/js/menus.js"></script>


<script>
  
  if (window.location.hostname != "localhost") {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'Your Google Analytics tracking ID', 'auto');
    ga('send', 'pageview');
  }
</script>







</body>
</html>

